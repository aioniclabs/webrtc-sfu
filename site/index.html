<script>
window.getIceServers = () => {
    return [
      {
        urls: "stun:stun.l.google.com:19302"
      },
      // also TURN servers here
    ];
}
</script>
<h2>Create publisher (per publisher security token setting for pushing streams)</h2>
(this will only be called from other in-cluster service for settings)<br/>
room: <input id="create_pub_room" type="text"></input><br/>
id: <input id="create_pub_id" type="text"></input><br/>
token: <input id="create_pub_token" type="text"></input><br/>
<button onclick="window.createPublisher()">Create Publisher</button><br/><br/>
Logs:<br/>
<div id="create_pub_log"></div>
<script>
window.createPublisher = () => {
  let log = msg => {
    document.getElementById("create_pub_log").innerHTML += msg + "<br>"
  }

  let room = document.getElementById("create_pub_room").value;
  let id = document.getElementById("create_pub_id").value;
  let token = document.getElementById("create_pub_token").value;
  let params = {
      "room": room,
      "id": id,
      "token": token,
  };

  fetch("/create/pub", {
    method: "POST",
    headers: {
      "Accept": "application/json",
      "Content-Type": "application/json",
    },
    body: JSON.stringify(params),
  }).then(res => {
    log(`Request complete! URL ${res.url} status ${res.status}`);
    res.text().then(function(answer) {
      log(answer);
    })
  });
}
</script>
<hr>

<!-- ---------- -->

<h2>Create subscriber (per subscriber security token setting for pulling streams)</h2>
(this will only be called from other in-cluster service for settings)<br/>
room: <input id="create_sub_room" type="text"></input><br/>
id: <input id="create_sub_id" type="text"></input><br/>
token: <input id="create_sub_token" type="text"></input><br/>
<button onclick="window.createSubscriber()">Create Subscriber</button><br/><br/>
Logs:<br/>
<div id="create_sub_log"></div>
<script>
window.createSubscriber = () => {
  let log = msg => {
    document.getElementById("create_sub_log").innerHTML += msg + "<br>"
  }

  let room = document.getElementById("create_sub_room").value;
  let id = document.getElementById("create_sub_id").value;
  let token = document.getElementById("create_sub_token").value;
  let params = {
      "room": room,
      "id": id,
      "token": token,
  };

  fetch("/create/sub", {
    method: "POST",
    headers: {
      "Accept": "application/json",
      "Content-Type": "application/json",
    },
    body: JSON.stringify(params),
  }).then(res => {
    log(`Request complete! URL ${res.url} status ${res.status}`);
    res.text().then(function(answer) {
      log(answer);
    })
  });
}
</script>
<hr>

<!-- ---------- -->

<h2>Run Publisher</h2>
room: <input id="run_pub_room" type="text"></input><br/>
id: <input id="run_pub_id" type="text"></input><br/>
token: <input id="run_pub_token" type="text"></input><br/>
enable video: <input type="checkbox" id="run_pub_enable_video" checked><br/>
enable audio: <input type="checkbox" id="run_pub_enable_audio" checked><br/>
video resolution: <select id="run_pub_video_resolution">
    <option value="240">240p</option>
    <option value="480">480p</option>
    <option value="720" selected>720p</option>
    <option value="1080">1080p</option>
    <option value="1440">1440p</option>
    <option value="2160">2160p (4K)</option>
    <option value="4320">4320p (8K)</option>
</select><br/>
video framerate: <input type="number" id="run_pub_video_framerate" min="0" max="60" value="30"></br>
<button id="run_pub_start" onclick="window.runPublisher()">Run Publisher</button>
<button id="run_pub_stop" hidden>Stop Publisher</button><br/><br/>
<button id="run_pub_screenshare" hidden> Start Screen Share </button>
<button id="run_pub_screenshare_stop" hidden> Stop Screen Share </button><br />
<video id="pub_video" width="160" height="120" autoplay muted></video><br />
<video id="pub_video_screenshare" width="160" height="120" autoplay muted></video><br />
local offer: <br/><textarea id="pubLocalSessionDescription" readonly="true"></textarea>
<br/>
remote answer: <br/><textarea id="pubRemoteSessionDescription" readonly="true"></textarea>
<br/>
selected local candidate: <div id="run_pub_local_ice"></div>
selected remote candidate: <div id="run_pub_remote_ice"></div>
Logs:<br/>
<div id="run_pub_log"></div>
<script>
window.runPublisher = () => {
  document.getElementById("run_pub_start").hidden = true;
  document.getElementById("run_pub_stop").hidden = false;
  document.getElementById("run_pub_screenshare").hidden = false;

  let log = msg => {
    document.getElementById("run_pub_log").innerHTML += msg + "<br>"
  }

  let pub_pc = new RTCPeerConnection({
    iceServers: window.getIceServers(),
  })

  pub_pc.oniceconnectionstatechange = e => {
    log(pub_pc.iceConnectionState);
    if (pub_pc.iceConnectionState == "connected") {
      pub_pc.getStats().then(s => {
        s.forEach(o => {
          // chrome
          if (o.state == "succeeded") {
            document.getElementById("run_pub_local_ice").innerHTML = JSON.stringify(s.get(o.localCandidateId));
            document.getElementById("run_pub_remote_ice").innerHTML = JSON.stringify(s.get(o.remoteCandidateId));
          }
          // firefox
          if (o.selected == true) {
            document.getElementById("run_pub_local_ice").innerHTML = JSON.stringify(s.get(o.localCandidateId));
            document.getElementById("run_pub_remote_ice").innerHTML = JSON.stringify(s.get(o.remoteCandidateId));
          }
        })
      })
    }
  }

  let sendChannel = pub_pc.createDataChannel("control", {"ordered": true, "maxRetransmits": 20})
  sendChannel.onclose = () => console.log("sendChannel has closed")
  sendChannel.onopen = () => console.log("sendChannel has opened")
  sendChannel.onmessage = e => {
    log(`Message from DataChannel "${sendChannel.label}" payload "${e.data}"`);

    if (sendChannel.label != "control") {
        return;
    }

    // do something
  }

  let _id = document.getElementById("run_pub_id").value;
  // use a trailing random id to avoid duplication from same publisher
  let trailing = "+" + (+new Date).toString(36);
  let id = _id + trailing;
  let _screen_id = _id + "-screen" + trailing;

  let media_track_constraits = {};
  if (document.getElementById("run_pub_enable_video").checked) {
    switch (document.getElementById("run_pub_video_resolution").value) {
      case "240":
        media_track_constraits["video"] = { "width": 320, "height": 240 };
        break;
      case "480":
        media_track_constraits["video"] = { "width": 640, "height": 480 };
        break;
      case "720":
        media_track_constraits["video"] = { "width": 1280, "height": 720 };
        break;
      case "1080":
        media_track_constraits["video"] = { "width": 1920, "height": 1080 };
        break;
      case "1440":
        media_track_constraits["video"] = { "width": 2560, "height": 1440 };
        break;
      case "2160":
        media_track_constraits["video"] = { "width": 3840, "height": 2160 };
        break;
      case "4320":
        media_track_constraits["video"] = { "width": 7680, "height": 4320 };
        break;
      default:
        media_track_constraits["video"] = { "width": 1280, "height": 720 };
    }
    media_track_constraits["video"]["frameRate"] = document.getElementById("run_pub_video_framerate").value
  }
  if (document.getElementById("run_pub_enable_audio").checked) {
    media_track_constraits["audio"] = { echoCancellation: true };
  }

  log("media constraints: " + JSON.stringify(media_track_constraits));

  navigator.mediaDevices.getUserMedia(media_track_constraits)
    .then(stream => {
      stream.getTracks().forEach(track => pub_pc.addTrack(track, stream))
      document.getElementById("pub_video").srcObject = stream

      let room = document.getElementById("run_pub_room").value;
      let token = document.getElementById("run_pub_token").value;

      pub_pc.createOffer()
        .then(offer => {
          pub_pc.setLocalDescription(offer);
          document.getElementById("pubLocalSessionDescription").value = offer.sdp;
          fetch(`/pub/${room}/${id}`, {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${token}`,
            },
            body: offer.sdp,
          }).then(res => {
            log(`Request complete! URL ${res.url} status ${res.status}`);
            res.text().then(function(answer) {
              document.getElementById("pubRemoteSessionDescription").value = answer;
              pub_pc.setRemoteDescription(new RTCSessionDescription({"type":"answer","sdp":answer}));
            })
          });
        })
        .catch(log);
    }).catch(log);


  // TODO: don't create new PC
  var pub_screen_pc;
  var sendChannelScreen;

  document.getElementById("run_pub_screenshare").onclick = () => {

    document.getElementById("run_pub_screenshare").hidden = true;
    document.getElementById("run_pub_screenshare_stop").hidden = false;

    navigator.mediaDevices.getDisplayMedia({video: true})
      .then(stream => {

        pub_screen_pc = new RTCPeerConnection({
          iceServers: window.getIceServers(),
        });

        sendChannelScreen = pub_screen_pc.createDataChannel("control", {"ordered": true, "maxRetransmits": 20});

        let room = document.getElementById("run_pub_room").value;
        let token = document.getElementById("run_pub_token").value;

        stream.getTracks().forEach(track => pub_screen_pc.addTrack(track, stream));
        document.getElementById("pub_video_screenshare").srcObject = stream;

        let screen_id = _screen_id + (+new Date).toString(36);

        pub_screen_pc.createOffer()
          .then(offer => {
            pub_screen_pc.setLocalDescription(offer);
            fetch(`/pub/${room}/${screen_id}`, {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${token}`,
              },
              body: offer.sdp,
            }).then(res => {
              log(`Request complete! URL ${res.url} status ${res.status}`);
              res.text().then(function(answer) {
                document.getElementById("pubRemoteSessionDescription").value = answer;
                pub_screen_pc.setRemoteDescription(new RTCSessionDescription({"type":"answer","sdp":answer}));
              })
            });
          })
          .catch(log);

        // TODO: use renegotiation instead of new PC
      }).catch(log);
  }

  document.getElementById("run_pub_stop").onclick = () => {
    sendChannel.send("STOP");
    document.getElementById("run_pub_start").hidden = false;
    document.getElementById("run_pub_stop").hidden = true;
    document.getElementById("run_pub_screenshare").hidden = true;
    document.getElementById("pub_video").srcObject = null;
    pub_pc.close();
  }

  document.getElementById("run_pub_screenshare_stop").onclick = () => {
    sendChannelScreen.send("STOP");
    document.getElementById("run_pub_screenshare").hidden = false;
    document.getElementById("run_pub_screenshare_stop").hidden = true;
    document.getElementById("pub_video_screenshare").srcObject = null;
    pub_screen_pc.close();
  }
}
</script>
<hr>

<!-- ---------- -->

<h2>Run Sublisher</h2>
room: <input id="run_sub_room" type="text"></input><br/>
id: <input id="run_sub_id" type="text"></input><br/>
token: <input id="run_sub_token" type="text"></input><br/>
local offer: <br/><textarea id="subLocalSessionDescription" readonly="true"></textarea><br/>
remote answer: <br/><textarea id="subRemoteSessionDescription" readonly="true"></textarea><br/>
selected local candidate: <div id="run_sub_local_ice"></div>
selected remote candidate: <div id="run_sub_remote_ice"></div>
<button id="run_sub_start" onclick="window.runSubscriber()"> Start Session </button>
<button id="run_sub_stop" hidden>Stop Session</button><br/><br/>
<br/>
Video<br/>
<div id="sub_videos"></div><br/><br />
message: <input id="sub_dc" type="text"></input><br/>
<button onclick="window.subSendMessage()">Send Message</button><br /><br />
Logs<br/>
<div id="sub_log"></div>
<script>
window.runSubscriber = () => {
  document.getElementById("run_sub_start").hidden = true;
  document.getElementById("run_sub_stop").hidden = false;

  let log = msg => {
    document.getElementById("sub_log").innerHTML += msg + "<br>"
  };

  let sub_pc = new RTCPeerConnection({
    iceServers: window.getIceServers(),
  });

  // for easier debug and trial only
  window.sub_pc = sub_pc;

  sub_pc.oniceconnectionstatechange = e => {
    log(sub_pc.iceConnectionState);
    if (sub_pc.iceConnectionState == "connected") {
      sub_pc.getStats().then(s => {
        s.forEach(o => {
          // chrome
          if (o.state == "succeeded") {
            document.getElementById("run_sub_local_ice").innerHTML = JSON.stringify(s.get(o.localCandidateId));
            document.getElementById("run_sub_remote_ice").innerHTML = JSON.stringify(s.get(o.remoteCandidateId));
          }
          // firefox
          if (o.selected == true) {
            document.getElementById("run_sub_local_ice").innerHTML = JSON.stringify(s.get(o.localCandidateId));
            document.getElementById("run_sub_remote_ice").innerHTML = JSON.stringify(s.get(o.remoteCandidateId));
          }
        })
      })
    }
  }

  let sendChannel = sub_pc.createDataChannel("control", {"ordered": true, "maxRetransmits": 20})
  sendChannel.onclose = () => console.log("sendChannel has closed")
  sendChannel.onopen = () => console.log("sendChannel has opened")
  sendChannel.onmessage = e => {
    log(`Message from DataChannel "${sendChannel.label}" payload "${e.data}"`);

    if (sendChannel.label != "control") {
        return;
    }

    if (e.data.startsWith("PUB_JOIN ") == true) {
      // do something
    }

    if (e.data.startsWith("PUB_LEFT ") == true) {
      const words = e.data.split(" ");
      let id = words[1];
      div = document.getElementById(`media-${id}`)
      if (div != null) {
        log(`remove media elements for ${id}`);
        div.remove()
      }
    }

    if (e.data.startsWith("SDP_OFFER ") == true) {
      log("set remote SDP offer again")
      let offer = e.data.slice(10);
      document.getElementById("subRemoteSessionDescription").value = offer;
      sub_pc.setRemoteDescription(new RTCSessionDescription({"type":"offer","sdp":offer}));
      sub_pc.createAnswer()
        .then(answer => {
          log("created local SDP answer")
          sub_pc.setLocalDescription(answer);
          document.getElementById("subLocalSessionDescription").value = answer.sdp;
          sendChannel.send("SDP_ANSWER " + answer.sdp);
        })
        .catch(log);
    }
  }

  window.subSendMessage = () => {
    let message = document.getElementById("sub_dc").value
    if (message === "") {
      return alert("Message must not be empty")
    }

    sendChannel.send(message)
  }

  sub_pc.ontrack = function (event) {
    if (event.streams == null) {
      return;
    }

    let id = event.streams[0].id

    // quick hack for hidden hardcode video stream that does not present
    if (id.startsWith("{")) {
      return;
    }

    log(`add track ${id} ${event.track.id}`);
    console.log(event);                      // TODO: remove this

    var div;
    div = document.getElementById(`media-${id}`)
    if (div == null) {
      div = document.createElement("div")
      div.id = `media-${id}`
      div.textContent = id
      document.getElementById("sub_videos").appendChild(div)
    }

    // video or audio here
    var media;
    media = document.getElementById(`media-${id}-${event.track.id}`)
    if (media == null) {
      media = document.createElement(event.track.kind)
      media.id = `media-${id}-${event.track.kind}-${event.track.id}`
      div.appendChild(media)
    }
    // TODO: multiple media streams?
    media.srcObject = event.streams[0]
    media.autoplay = true
    media.controls = true
  }

  sub_pc.createOffer()
    .then(offer => {
      sub_pc.setLocalDescription(offer);
      document.getElementById("subLocalSessionDescription").value = offer.sdp;

      let room = document.getElementById("run_sub_room").value;
      // use a trailing random id to avoid duplication from same publisher
      let id = document.getElementById("run_sub_id").value + "+" + (+new Date).toString(36);
      let token = document.getElementById("run_sub_token").value;

      fetch(`/sub/${room}/${id}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/sdp",
          "Authorization": `Bearer ${token}`,
        },
        body: offer.sdp,
      }).then(res => {
        log(`Request complete! URL ${res.url} status ${res.status}`);
        res.text().then(function(answer) {
          document.getElementById("subRemoteSessionDescription").value = answer;
          sub_pc.setRemoteDescription(new RTCSessionDescription({"type":"answer","sdp":answer}));
        })
      });
    })
    .catch(log);

  document.getElementById("run_sub_stop").onclick = () => {
    sendChannel.send("STOP");
    document.getElementById("run_sub_start").hidden = false;
    document.getElementById("run_sub_stop").hidden = true;
    document.getElementById("sub_videos").textContent = '';
    sub_pc.close();
  }
}
</script>

<style>
textarea {
    width: 500px;
    min-height: 375px;
}
video {
    max-height: 200;
}
</style>
<hr>

<!-- ---------- -->

<h2>List Publishers</h2>
room: <input id="list_pubs_room" type="text"></input><br/>
<button onclick="window.listPublishers()">List Publishers</button><br/><br/>
Logs:<br/>
<div id="list_pubs_log"></div>
<script>
window.listPublishers = () => {
  let log = msg => {
    document.getElementById("list_pubs_log").innerHTML += msg + "<br>"
  }

  let room = document.getElementById("list_pubs_room").value;

  fetch(`/list/pub/${room}`, {
    method: "GET",
  }).then(res => {
    log(`Request complete! URL ${res.url} status ${res.status}`);
    res.text().then(function(answer) {
      log(answer);
    })
  });
}
</script>
<hr>

<!-- ---------- -->

<h2>List Subscribers</h2>
room: <input id="list_subs_room" type="text"></input><br/>
<button onclick="window.listSubscribers()">List Subscribers</button><br/><br/>
Logs:<br/>
<div id="list_subs_log"></div>
<script>
window.listSubscribers = () => {
  let log = msg => {
    document.getElementById("list_subs_log").innerHTML += msg + "<br>"
  }

  let room = document.getElementById("list_subs_room").value;

  fetch(`/list/sub/${room}`, {
    method: "GET",
  }).then(res => {
    log(`Request complete! URL ${res.url} status ${res.status}`);
    res.text().then(function(answer) {
      log(answer);
    })
  });
}
</script>
<hr>
