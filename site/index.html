<script>
// some functions for reuse and easier console test

window.getIceServers = () => {
    return [
      {
        urls: "stun:stun.l.google.com:19302"
      },
      // also TURN servers here
    ];
}

window.sendSDPOfferHTTP = function(pc, offer, type, room, id, token, answerId, log) {
  log("send SDP offer via HTTP POST")
  fetch(`/${type}/${room}/${id}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/sdp",
      "Authorization": `Bearer ${token}`,
    },
    body: offer.sdp,
  }).then(res => {
    log(`Request complete! URL ${res.url} status ${res.status}`);
    res.text().then(function(answer) {
      document.getElementById(answerId).value = answer;
      pc.setRemoteDescription(new RTCSessionDescription({"type":"answer","sdp":answer}));
    })
  });
}

window.sendSDPOfferDataChannel = function(dc, offer, log) {
  log("send SDP offer via Data Channel")
  dc.send("SDP_OFFER " + offer.sdp);
}
</script>

<!-- ---------- -->

<h2>Run Publisher</h2>
room: <input id="run_pub_room" type="text"></input><br/>
id: <input id="run_pub_id" type="text"></input><br/>
token: <input id="run_pub_token" type="text"></input><br/>
enable video: <input type="checkbox" id="run_pub_enable_video" checked><br/>
enable audio: <input type="checkbox" id="run_pub_enable_audio" checked><br/>
video resolution: <select id="run_pub_video_resolution">
    <option value="240">240p</option>
    <option value="480">480p</option>
    <option value="720" selected>720p</option>
    <option value="1080">1080p</option>
    <option value="1440">1440p</option>
    <option value="2160">2160p (4K)</option>
    <option value="4320">4320p (8K)</option>
</select><br/>
video framerate: <input type="number" id="run_pub_video_framerate" min="0" max="60" value="30"></br>
<button id="run_pub_start" onclick="window.runPublisher()"> Start Session </button>
<button id="run_pub_stop" hidden>Stop Publisher</button><br/><br/>
<button id="run_pub_screenshare" hidden> Start Screen Share </button>
<button id="run_pub_screenshare_stop" hidden> Stop Screen Share </button><br /><br />
<!-- <button id="run_pub_ice_restart"> Ice Restart </button><br /> -->
<!-- message: <input id="pub_dc" type="text"></input><br/> -->
<!-- <button onclick="window.pubSendMessage()">Send Message</button><br /><br /> -->
<video id="pub_video" width="160" height="120" autoplay muted></video><br />
<video id="pub_video_screenshare" width="160" height="120" autoplay muted></video><br />
local offer: <br/><textarea id="pubLocalSessionDescription" readonly="true"></textarea>
<br/>
remote answer: <br/><textarea id="pubRemoteSessionDescription" readonly="true"></textarea>
<br/>
selected local candidate: <div id="run_pub_local_ice"></div>
selected remote candidate: <div id="run_pub_remote_ice"></div>
Logs:<br/>
<div id="run_pub_log"></div>
<script>
window.runPublisher = () => {
  // some buttons toggle
  document.getElementById("run_pub_start").hidden = true;
  document.getElementById("run_pub_stop").hidden = false;
  document.getElementById("run_pub_screenshare").hidden = false;

  // append log to specific div
  let log = msg => {
    document.getElementById("run_pub_log").innerHTML += msg + "<br>"
  }

  // create WebRTC connection object (this only manipulate browser objects, it does not setup the connection yet)
  let pub_pc = new RTCPeerConnection({
    iceServers: window.getIceServers(),
  })

  // for easier debug and trial only
  window.pub_pc = pub_pc;

  // time profiling
  let timestamp_create_offer = Date.now();

  // flag to control ICE restart
  let is_ice_restart = false;

  // ICE connection state change callback
  pub_pc.oniceconnectionstatechange = e => {
    log(pub_pc.iceConnectionState);
    // show final selected ICE candidate on website
    if (pub_pc.iceConnectionState == "connected") {
      pub_pc.getStats().then(s => {
        s.forEach(o => {
          // chrome
          if (o.state == "succeeded") {
            document.getElementById("run_pub_local_ice").innerHTML = JSON.stringify(s.get(o.localCandidateId));
            document.getElementById("run_pub_remote_ice").innerHTML = JSON.stringify(s.get(o.remoteCandidateId));
          }
          // firefox
          if (o.selected == true) {
            document.getElementById("run_pub_local_ice").innerHTML = JSON.stringify(s.get(o.localCandidateId));
            document.getElementById("run_pub_remote_ice").innerHTML = JSON.stringify(s.get(o.remoteCandidateId));
          }
        })
      })
    }
  }

  // trickle ICE candidate calllback
  pub_pc.onicecandidate = function(event) {
    if (event.candidate) {
      // log the candidate without sending to peer
      // TODO: have a way to send the ICE candidate one by one immediately
      log("trickle ICE: " + JSON.stringify(event.candidate));
    } else {
      // time profiling
      let timestamp_ice_collected = Date.now();
      let ice_duration = timestamp_ice_collected - timestamp_create_offer;
      log(`from createOffer() to full ICE collected: ${ice_duration} ms`);

      // all ICE candidates have been collected
      let offer = pub_pc.localDescription;
      document.getElementById("pubLocalSessionDescription").value = offer.sdp;

      // get parameters from input
      let room = document.getElementById("run_pub_room").value;
      // use a trailing random id to avoid duplication from same publisher
      let id = document.getElementById("run_pub_id").value + "+" + (+new Date).toString(36);
      let token = document.getElementById("run_pub_token").value;

      // decide the way we send SDP offer based on ICE restart or not
      if (is_ice_restart == true) {
        is_ice_restart = false;
        // window.sendSDPOfferDataChannel(dataChannel, offer, log);
        window.sendSDPOfferHTTP(pub_pc, offer, "pub", room, id, token, "pubRemoteSessionDescription", log);
      } else {
        window.sendSDPOfferHTTP(pub_pc, offer, "pub", room, id, token, "pubRemoteSessionDescription", log);
      }
    }
  }

  // button for triggering ICE restart
  // document.getElementById("run_pub_ice_restart").onclick = () => {
  //   // time profiling
  //   timestamp_start = Date.now();
  //   timestamp_create_offer = Date.now();

  //   is_ice_restart = true;

  //   pub_pc.createOffer({"iceRestart": true})
  //     .then(offer => {
  //       pub_pc.setLocalDescription(offer);
  //       document.getElementById("pubLocalSessionDescription").value = offer.sdp;
  //     })
  //     .catch(log);
  // }

  // setup a data channel (this only manipulate browser objects, it does not setup the connection yet)
  let dataChannel = pub_pc.createDataChannel("control", {"ordered": true, "maxRetransmits": 20})
  dataChannel.onclose = () => log("DataChannel has closed")
  dataChannel.onopen = () => log("DataChannel has opened")
  dataChannel.onmessage = e => {
    log(`Message from DataChannel "${dataChannel.label}" payload "${e.data}"`);

    if (dataChannel.label != "control") {
        return;
    }

    // do something
  }

  // function for sending messages via data channel
  // will be used by button for testing too
  window.pubSendMessage = () => {
    let message = document.getElementById("pub_dc").value
    if (message === "") {
      return alert("Message must not be empty")
    }

    dataChannel.send(message)
  }

  // media settings
  // e.g. enable video/audio or not, video resolution, video framerate
  let media_track_constraits = {};
  if (document.getElementById("run_pub_enable_video").checked) {
    switch (document.getElementById("run_pub_video_resolution").value) {
      case "240":
        media_track_constraits["video"] = { "width": 320, "height": 240 };
        break;
      case "480":
        media_track_constraits["video"] = { "width": 640, "height": 480 };
        break;
      case "720":
        media_track_constraits["video"] = { "width": 1280, "height": 720 };
        break;
      case "1080":
        media_track_constraits["video"] = { "width": 1920, "height": 1080 };
        break;
      case "1440":
        media_track_constraits["video"] = { "width": 2560, "height": 1440 };
        break;
      case "2160":
        media_track_constraits["video"] = { "width": 3840, "height": 2160 };
        break;
      case "4320":
        media_track_constraits["video"] = { "width": 7680, "height": 4320 };
        break;
      default:
        media_track_constraits["video"] = { "width": 1280, "height": 720 };
    }
    media_track_constraits["video"]["frameRate"] = document.getElementById("run_pub_video_framerate").value
  }
  if (document.getElementById("run_pub_enable_audio").checked) {
    media_track_constraits["audio"] = { echoCancellation: true };
  }

  log("media constraints: " + JSON.stringify(media_track_constraits));

  // get media devices permission based on settings (can have video or audio or both)
  navigator.mediaDevices.getUserMedia(media_track_constraits)
    .then(stream => {
      stream.getTracks().forEach(track => pub_pc.addTrack(track, stream))

      // show video on our own web page
      document.getElementById("pub_video").srcObject = stream

      // time profiling
      timestamp_create_offer = Date.now();

      pub_pc.createOffer()
        .then(offer => {
          pub_pc.setLocalDescription(offer);
          document.getElementById("pubLocalSessionDescription").value = offer.sdp;
        })
        .catch(log);
    }).catch(log);


  //////////////////////////////
  // screen share
  //////////////////////////////

  // TODO: don't create new PC, use WebRTC renegotiation to add new video stream
  var pub_screen_pc;
  var dataChannelScreen;

  document.getElementById("run_pub_screenshare").onclick = () => {
    // some buttons toggle
    document.getElementById("run_pub_screenshare").hidden = true;
    document.getElementById("run_pub_screenshare_stop").hidden = false;

    // get media devices permission based on settings
    navigator.mediaDevices.getDisplayMedia({video: true})
      .then(stream => {

        // create WebRTC connection object (this only manipulate browser objects, it does not setup the connection yet)
        pub_screen_pc = new RTCPeerConnection({
          iceServers: window.getIceServers(),
        });

        // setup a data channel (this only manipulate browser objects, it does not setup the connection yet)
        dataChannelScreen = pub_screen_pc.createDataChannel("control", {"ordered": true, "maxRetransmits": 20});

        stream.getTracks().forEach(track => pub_screen_pc.addTrack(track, stream));
        document.getElementById("pub_video_screenshare").srcObject = stream;

        let room = document.getElementById("run_pub_room").value;
        let token = document.getElementById("run_pub_token").value;
        let _id = document.getElementById("run_pub_id").value;
        let screen_id = _id + "-screen" + "+" + (+new Date).toString(36);

        pub_screen_pc.createOffer()
          .then(offer => {
            pub_screen_pc.setLocalDescription(offer);
            window.sendSDPOfferHTTP(pub_screen_pc, offer, "pub", room, screen_id, token, "pubRemoteSessionDescription", log);
          })
          .catch(log);
      }).catch(log);
  }

  // button for stopping the WebRTC connection
  document.getElementById("run_pub_stop").onclick = () => {
    dataChannel.send("STOP");
    document.getElementById("run_pub_start").hidden = false;
    document.getElementById("run_pub_stop").hidden = true;
    document.getElementById("run_pub_screenshare").hidden = true;
    document.getElementById("pub_video").srcObject = null;
    pub_pc.close();
  }

  // button for stopping the screen share
  document.getElementById("run_pub_screenshare_stop").onclick = () => {
    dataChannelScreen.send("STOP");
    document.getElementById("run_pub_screenshare").hidden = false;
    document.getElementById("run_pub_screenshare_stop").hidden = true;
    document.getElementById("pub_video_screenshare").srcObject = null;
    pub_screen_pc.close();
  }
}
</script>
<hr>

<!-- ---------- -->

<h2>Run Sublisher</h2>
room: <input id="run_sub_room" type="text"></input><br/>
id: <input id="run_sub_id" type="text"></input><br/>
token: <input id="run_sub_token" type="text"></input><br/>
<button id="run_sub_start" onclick="window.runSubscriber()"> Start Session </button>
<br/>
<br/>
Videos:<br/>
<div id="sub_videos"></div><br/><br />
local offer: <br/><textarea id="subLocalSessionDescription" readonly="true"></textarea><br/>
remote answer: <br/><textarea id="subRemoteSessionDescription" readonly="true"></textarea><br/>
selected local candidate: <div id="run_sub_local_ice"></div>
selected remote candidate: <div id="run_sub_remote_ice"></div>
<button id="run_sub_stop" hidden>Stop Session</button><br/><br/>
<!-- <button id="run_sub_ice_restart"> Ice Restart </button><br /> -->
<!-- message: <input id="sub_dc" type="text"></input><br/> -->
<!-- <button onclick="window.subSendMessage()">Send Message</button><br /><br /> -->
Logs<br/>
<div id="sub_log"></div>
<script>
window.runSubscriber = () => {
  // some buttons toggle
  document.getElementById("run_sub_start").hidden = true;
  document.getElementById("run_sub_stop").hidden = false;

  // append log to specific div
  let log = msg => {
    document.getElementById("sub_log").innerHTML += msg + "<br>"
  };

  // time profiling
  let timestamp_start = Date.now();

  // flag to control ICE restart
  let is_ice_restart = false;

  // create WebRTC connection object (this only manipulate browser objects, it does not setup the connection yet)
  let sub_pc = new RTCPeerConnection({
    iceServers: window.getIceServers(),
  });

  // for easier debug and trial only
  window.sub_pc = sub_pc;

  // ICE connection state change callback
  sub_pc.oniceconnectionstatechange = e => {
    log(sub_pc.iceConnectionState);
    // show final selected ICE candidate on website
    if (sub_pc.iceConnectionState == "connected") {
      // time profiling
      let timestamp_connected = Date.now();
      let connect_duration = timestamp_connected - timestamp_start;
      log(`from start to connected: ${connect_duration} ms`);

      sub_pc.getStats().then(s => {
        s.forEach(o => {
          // chrome
          if (o.state == "succeeded") {
            document.getElementById("run_sub_local_ice").innerHTML = JSON.stringify(s.get(o.localCandidateId));
            document.getElementById("run_sub_remote_ice").innerHTML = JSON.stringify(s.get(o.remoteCandidateId));
          }
          // firefox
          if (o.selected == true) {
            document.getElementById("run_sub_local_ice").innerHTML = JSON.stringify(s.get(o.localCandidateId));
            document.getElementById("run_sub_remote_ice").innerHTML = JSON.stringify(s.get(o.remoteCandidateId));
          }
        })
      })
    }
  }

  // ICE connection state change callback
  sub_pc.onicecandidate = function(event) {
    if (event.candidate) {
      // log the candidate without sending to peer
      // TODO: have a way to send the ICE candidate one by one immediately
      log("trickle ICE: " + JSON.stringify(event.candidate));
    } else {
      // time profiling
      let timestamp_ice_collected = Date.now();
      let ice_duration = timestamp_ice_collected - timestamp_create_offer;
      log(`from createOffer() to full ICE collected: ${ice_duration} ms`);

      // all ICE candidates have been collected
      let offer = sub_pc.localDescription;
      document.getElementById("subLocalSessionDescription").value = offer.sdp;

      // get parameters from input
      let room = document.getElementById("run_sub_room").value;
      // use a trailing random id to avoid duplication from same publisher
      let id = document.getElementById("run_sub_id").value + "+" + (+new Date).toString(36);
      let token = document.getElementById("run_sub_token").value;

      // decide the way we send SDP offer based on ICE restart or not
      if (is_ice_restart == true) {
        is_ice_restart = false;
        // window.sendSDPOfferDataChannel(dataChannel, offer, log);
        window.sendSDPOfferHTTP(sub_pc, offer, "sub", room, id, token, "subRemoteSessionDescription", log);
      } else {
        window.sendSDPOfferHTTP(sub_pc, offer, "sub", room, id, token, "subRemoteSessionDescription", log);
      }
    }
  }

  // setup a data channel (this only manipulate browser objects, it does not setup the connection yet)
  let dataChannel = sub_pc.createDataChannel("control", {"ordered": true, "maxRetransmits": 20})
  dataChannel.onclose = () => console.log("dataChannel has closed")
  dataChannel.onopen = () => console.log("dataChannel has opened")
  dataChannel.onmessage = e => {
    log(`Message from DataChannel "${dataChannel.label}" payload "${e.data}"`);

    if (dataChannel.label != "control") {
        return;
    }

    if (e.data.startsWith("PUB_JOIN ") == true) {
      // do something
    }

    if (e.data.startsWith("PUB_LEFT ") == true) {
      const words = e.data.split(" ");
      let id = words[1];
      div = document.getElementById(`media-${id}`)
      if (div != null) {
        log(`remove media elements for ${id}`);
        div.remove()
      }
    }

    if (e.data.startsWith("SDP_OFFER ") == true) {
      log("set remote SDP offer again")
      let offer = e.data.slice(10);
      document.getElementById("subRemoteSessionDescription").value = offer;
      sub_pc.setRemoteDescription(new RTCSessionDescription({"type":"offer","sdp":offer}));
      sub_pc.createAnswer()
        .then(answer => {
          log("created local SDP answer")
          sub_pc.setLocalDescription(answer);
          document.getElementById("subLocalSessionDescription").value = answer.sdp;
          dataChannel.send("SDP_ANSWER " + answer.sdp);
        })
        .catch(log);
    }
  }

  // button for triggering ICE restart
  // document.getElementById("run_sub_ice_restart").onclick = () => {
  //   // time profiling
  //   timestamp_start = Date.now();
  //   timestamp_create_offer = Date.now();

  //   is_ice_restart = true

  //   sub_pc.createOffer({"iceRestart": true})
  //     .then(offer => {
  //       sub_pc.setLocalDescription(offer);
  //       document.getElementById("subLocalSessionDescription").value = offer.sdp;
  //     })
  //     .catch(log);
  // }

  // function for sending messages via data channel
  // will be used by button for testing too
  window.subSendMessage = () => {
    let message = document.getElementById("sub_dc").value
    if (message === "") {
      return alert("Message must not be empty")
    }

    dataChannel.send(message)
  }

  // new media track callback
  // we will also get user id from the stream id (embedded in SDP by design)
  sub_pc.ontrack = function (event) {
    if (event.streams == null) {
      return;
    }

    let id = event.streams[0].id

    // quick hack for hidden hardcode video stream that does not present
    if (id.startsWith("{")) {
      return;
    }

    log(`add track ${id} ${event.track.id}`);
    console.log(event);                      // TODO: remove this

    var div;
    div = document.getElementById(`media-${id}`)
    if (div == null) {
      div = document.createElement("div")
      div.id = `media-${id}`
      div.textContent = id
      document.getElementById("sub_videos").appendChild(div)
    }

    // video or audio here
    var media;
    media = document.getElementById(`media-${id}-${event.track.id}`)
    if (media == null) {
      media = document.createElement(event.track.kind)
      media.id = `media-${id}-${event.track.kind}-${event.track.id}`
      div.appendChild(media)
    }
    // TODO: multiple media streams?
    media.srcObject = event.streams[0]
    media.autoplay = true
    media.controls = true
  }

  // time profiling
  let timestamp_create_offer = Date.now();

  // create first SDP offer
  sub_pc.createOffer()
    .then(offer => {
      sub_pc.setLocalDescription(offer);
      document.getElementById("subLocalSessionDescription").value = offer.sdp;
    })
    .catch(log);

  // button for stopping the WebRTC connection
  document.getElementById("run_sub_stop").onclick = () => {
    dataChannel.send("STOP");
    document.getElementById("run_sub_start").hidden = false;
    document.getElementById("run_sub_stop").hidden = true;
    document.getElementById("sub_videos").textContent = '';
    sub_pc.close();
  }
}
</script>

<style>
textarea {
    width: 500px;
    min-height: 375px;
}
video {
    max-height: 200;
}
</style>
<hr>
