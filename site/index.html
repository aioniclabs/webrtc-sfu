<h2>Create publisher (per publisher security token setting for pushing streams)</h2>
(this will only be called from other in-cluster service for settings)<br/>
room: <input id="create_pub_room" type="text"></input><br/>
id: <input id="create_pub_id" type="text"></input><br/>
token: <input id="create_pub_token" type="text"></input><br/>
<button onclick="window.createPublisher()">Create Publisher</button><br/><br/>
Logs:<br/>
<div id="create_pub_log"></div>
<script>
window.createPublisher = () => {
  let log = msg => {
    document.getElementById("create_pub_log").innerHTML += msg + "<br>"
  }

  let room = document.getElementById("create_pub_room").value;
  let id = document.getElementById("create_pub_id").value;
  let token = document.getElementById("create_pub_token").value;
  let params = {
      "room": room,
      "id": id,
      "token": token,
  };

  fetch("/create/pub", {
    method: "POST",
    headers: {
      "Accept": "application/json",
      "Content-Type": "application/json",
    },
    body: JSON.stringify(params),
  }).then(res => {
    log(`Request complete! URL ${res.url} status ${res.status}`);
    res.text().then(function(answer) {
      log(answer);
    })
  });
}
</script>
<hr>

<h2>Create subscriber (per subscriber security token setting for pulling streams)</h2>
(this will only be called from other in-cluster service for settings)<br/>
room: <input id="create_sub_room" type="text"></input><br/>
id: <input id="create_sub_id" type="text"></input><br/>
token: <input id="create_sub_token" type="text"></input><br/>
<button onclick="window.createSubscriber()">Create Subscriber</button><br/><br/>
Logs:<br/>
<div id="create_sub_log"></div>
<script>
window.createSubscriber = () => {
  let log = msg => {
    document.getElementById("create_sub_log").innerHTML += msg + "<br>"
  }

  let room = document.getElementById("create_sub_room").value;
  let id = document.getElementById("create_sub_id").value;
  let token = document.getElementById("create_sub_token").value;
  let params = {
      "room": room,
      "id": id,
      "token": token,
  };

  fetch("/create/sub", {
    method: "POST",
    headers: {
      "Accept": "application/json",
      "Content-Type": "application/json",
    },
    body: JSON.stringify(params),
  }).then(res => {
    log(`Request complete! URL ${res.url} status ${res.status}`);
    res.text().then(function(answer) {
      log(answer);
    })
  });
}
</script>
<hr>

<h2>Run Publisher</h2>
room: <input id="run_pub_room" type="text"></input><br/>
id: <input id="run_pub_id" type="text"></input><br/>
token: <input id="run_pub_token" type="text"></input><br/>
<button onclick="window.runPublisher()">Run Publisher</button><br/><br/>
<video id="pub_video" width="160" height="120" autoplay muted></video><br />
local offer: <br/><textarea id="pubLocalSessionDescription" readonly="true"></textarea>
<br/>
remote answer: <br/><textarea id="pubRemoteSessionDescription" readonly="true"></textarea>
<br/>
Logs:<br/>
<div id="run_pub_log"></div>
<script>
window.runPublisher = () => {
  let log = msg => {
    document.getElementById("run_pub_log").innerHTML += msg + "<br>"
  }

  let pub_pc = new RTCPeerConnection({
    iceServers: [
      {
        urls: "stun:stun.l.google.com:19302"
      }
    ]
  })

  pub_pc.oniceconnectionstatechange = e => log(pub_pc.iceConnectionState);
  pub_pc.onicecandidate = event => {
    if (event.candidate === null) {
      document.getElementById("pubLocalSessionDescription").value = pub_pc.localDescription.sdp
    }
  }

  navigator.mediaDevices.getUserMedia({ video: true, audio: true })
    .then(stream => {
      stream.getTracks().forEach(track => pub_pc.addTrack(track, stream))
      document.getElementById("pub_video").srcObject = stream

      let room = document.getElementById("run_pub_room").value;
      let id = document.getElementById("run_pub_id").value;
      let token = document.getElementById("run_pub_token").value;

      pub_pc.createOffer()
        .then(offer => {
          pub_pc.setLocalDescription(offer);
          fetch(`/pub/${room}/${id}`, {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${token}`,
            },
            body: offer.sdp,
          }).then(res => {
            log(`Request complete! URL ${res.url} status ${res.status}`);
            res.text().then(function(answer) {
              document.getElementById("pubRemoteSessionDescription").value = answer;
              pub_pc.setRemoteDescription(new RTCSessionDescription({"type":"answer","sdp":answer}));
            })
          });
        })
        .catch(log);
    }).catch(log);
}
</script>
<hr>

<h2>Run Sublisher</h2>
room: <input id="run_sub_room" type="text"></input><br/>
id: <input id="run_sub_id" type="text"></input><br/>
token: <input id="run_sub_token" type="text"></input><br/>
local offer: <br/><textarea id="subLocalSessionDescription" readonly="true"></textarea><br/>
remote answer: <br/><textarea id="subRemoteSessionDescription" readonly="true"></textarea><br/>
<button onclick="window.runSubscriber()"> Start Session </button><br />
<br/>
Video<br/>
<div id="sub_videos"></div><br/><br />
message: <input id="sub_dc" type="text"></input><br/>
<button onclick="window.subSendMessage()">Send Message</button><br /><br />
Logs<br/>
<div id="sub_log"></div>
<script>
window.runSubscriber = () => {
  let log = msg => {
    document.getElementById("sub_log").innerHTML += msg + "<br>"
  };

  let sub_pc = new RTCPeerConnection({
    iceServers: [
      {
        urls: "stun:stun.l.google.com:19302"
      }
    ]
  });

  // for easier debug and trial only
  window.sub_pc = sub_pc;

  // TODO: is there any API under PeerConnection can do this?
  class DefaultDict {
     constructor(defaultInit) {
        return new Proxy({}, {
           get: (target, name) => name in target ?
              target[name] : (target[name] = typeof defaultInit === 'function' ?
                 new defaultInit().valueOf() :
                 defaultInit)
        })
     }
  }

  id_to_track_events = new DefaultDict(Array);

  // for easier debug and trial only
  window.id_to_track_events = id_to_track_events;

  sub_pc.oniceconnectionstatechange = e => log(sub_pc.iceConnectionState);
  sub_pc.onicecandidate = event => {
    if (event.candidate === null) {
      document.getElementById("subLocalSessionDescription").value = sub_pc.localDescription.sdp
    }
  }

  let sendChannel = sub_pc.createDataChannel("control")
  sendChannel.onclose = () => console.log("sendChannel has closed")
  sendChannel.onopen = () => console.log("sendChannel has opened")
  sendChannel.onmessage = e => {
    log(`Message from DataChannel "${sendChannel.label}" payload "${e.data}"`);

    if (sendChannel.label != "control") {
        return;
    }

    if (e.data.startsWith("PUB_JOIN ") == true) {
      const words = e.data.split(" ");
      let id = words[1];
      div = document.getElementById(`media-${id}`)
      // we don't delete tracks
      // when publisher rejoin, we will replace track and show it again
      if (div != null) {
        div.hidden = false;
      }
    }

    if (e.data.startsWith("PUB_LEFT ") == true) {
      const words = e.data.split(" ");
      let id = words[1];
      div = document.getElementById(`media-${id}`)
      if (div != null) {
        log(`remove media elements for ${id}`);
        // we don't remove track
        // we hide it, and reuse it when publisher rejoin
        div.hidden = true;
      }
      id_to_track_events[id].forEach(event => {
          console.log(event);
          // log(`remove track ${event.track.id} kind ${event.track.kind} mid ${event.transceiver.mid}`);
          // sub_pc.removeTrack(event.transceiver.sender);
          // event.transceiver.stop();
      });
      // delete id_to_track_events[id];
    }

    if (e.data.startsWith("RENEGOTIATION ") == true) {
      const words = e.data.split(" ");
      let videos = parseInt(words[2], 10);
      let audios = parseInt(words[4], 10);
      log(`all_videos ${videos}`);
      log(`all_audios ${audios}`);

      let current_videos = 0;
      let current_audios = 0;
      for (let transceiver of sub_pc.getTransceivers()) {
        if (transceiver.stopped == true) {
            continue;
        }
        if (transceiver.receiver.track.kind == "video") {
          current_videos += 1;
        } else if (transceiver.receiver.track.kind == "audio") {
          current_audios += 1;
        }
      }
      log(`current_videos ${current_videos}`);
      log(`current_audios ${current_audios}`);

      if (videos > current_videos) {
        // add more video transceivers
        for (const _ of Array(videos - current_videos).keys()) {
          sub_pc.addTransceiver("video", {"direction": "recvonly"})
          log("add video transceiver");
        }
      }

      if (audios > current_audios) {
        // add more audio transceivers
        for (const _ of Array(audios - current_audios).keys()) {
          sub_pc.addTransceiver("audio", {"direction": "recvonly"})
          log("add audio transceiver");
        }
      }

      // TODO: remove transceivers?
      // TODO: better transceivers or tracks update mechanism?

      sub_pc.createOffer()
        .then(offer => {
          log("created SDP offer again")
          sub_pc.setLocalDescription(offer);
          document.getElementById("subLocalSessionDescription").value = offer.sdp;
          sendChannel.send("SDP_OFFER " + offer.sdp);
        })
        .catch(log);
    }

    if (e.data.startsWith("SDP_ANSWER ") == true) {
      log("set SDP answer again")
      let answer = e.data.slice(11);
      document.getElementById("subRemoteSessionDescription").value = answer;
      sub_pc.setRemoteDescription(new RTCSessionDescription({"type":"answer","sdp":answer}));
    }
  }

  window.subSendMessage = () => {
    let message = document.getElementById("sub_dc").value
    if (message === "") {
      return alert("Message must not be empty")
    }

    sendChannel.send(message)
  }

  sub_pc.ontrack = function (event) {
    if (event.streams == null) {
      return;
    }

    let id = event.streams[0].id

    // quick hack for hidden hardcode video stream that does not present
    if (id.startsWith("{")) {
      return;
    }

    var div;
    div = document.getElementById(`media-${id}`)

    // cache it for later cleanup
    // TODO: is there any API under PeerConnection can do this?
    // TODO: we can only get the track GUID here? any other API?
    log(`add track ${id} ${event.track.id}`);
    id_to_track_events[id].push(event);
    console.log(event);                      // TODO: remove this

    if (div == null) {
      div = document.createElement("div")
      div.id = `media-${id}`
      div.textContent = id
    }

    // video or audio here
    let media = document.createElement(event.track.kind)

    // TODO: multiple media streams?
    media.srcObject = event.streams[0]
    media.autoplay = true
    media.controls = true

    div.appendChild(media)
    document.getElementById("sub_videos").appendChild(div)
  }

  sub_pc.createOffer()
    .then(offer => {
      sub_pc.setLocalDescription(offer);
      document.getElementById("subLocalSessionDescription").value = offer.sdp;

      let room = document.getElementById("run_sub_room").value;
      let id = document.getElementById("run_sub_id").value;
      let token = document.getElementById("run_sub_token").value;

      fetch(`/sub/${room}/${id}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/sdp",
          "Authorization": `Bearer ${token}`,
        },
        body: offer.sdp,
      }).then(res => {
        log(`Request complete! URL ${res.url} status ${res.status}`);
        res.text().then(function(answer) {
          document.getElementById("subRemoteSessionDescription").value = answer;
          sub_pc.setRemoteDescription(new RTCSessionDescription({"type":"answer","sdp":answer}));
        })
      });
    })
    .catch(log);
}
</script>

<style>
textarea {
    width: 500px;
    min-height: 375px;
}
video {
    max-height: 200;
}
</style>
