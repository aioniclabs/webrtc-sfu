<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Weever Streaming</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="getting-started/getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/introduction.html"><strong aria-hidden="true">1.1.</strong> Introduction</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/concepts.html"><strong aria-hidden="true">2.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/webrtc-sfu.html"><strong aria-hidden="true">2.1.</strong> WebRTC SFU</a></li><li class="chapter-item expanded "><a href="concepts/sdp.html"><strong aria-hidden="true">2.2.</strong> SDP</a></li><li class="chapter-item expanded "><a href="concepts/ice.html"><strong aria-hidden="true">2.3.</strong> ICE</a></li><li class="chapter-item expanded "><a href="concepts/stun.html"><strong aria-hidden="true">2.4.</strong> STUN</a></li><li class="chapter-item expanded "><a href="concepts/turn.html"><strong aria-hidden="true">2.5.</strong> TURN</a></li><li class="chapter-item expanded "><a href="concepts/publisher-subscriber.html"><strong aria-hidden="true">2.6.</strong> Publisher & Subscriber</a></li><li class="chapter-item expanded "><a href="concepts/room.html"><strong aria-hidden="true">2.7.</strong> Room</a></li><li class="chapter-item expanded "><a href="concepts/multistream.html"><strong aria-hidden="true">2.8.</strong> Multistream</a></li><li class="chapter-item expanded "><a href="concepts/webrtc-renegotiation.html"><strong aria-hidden="true">2.9.</strong> WebRTC Renegotiation</a></li><li class="chapter-item expanded "><a href="concepts/whip-whep.html"><strong aria-hidden="true">2.10.</strong> WHIP & WHEP</a></li><li class="chapter-item expanded "><a href="concepts/client-as-sdp-offer-first.html"><strong aria-hidden="true">2.11.</strong> Client as SDP Offer first</a></li><li class="chapter-item expanded "><a href="concepts/authentication.html"><strong aria-hidden="true">2.12.</strong> Authentication</a></li></ol></li><li class="chapter-item expanded "><a href="server/server.html"><strong aria-hidden="true">3.</strong> Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="server/room-management.html"><strong aria-hidden="true">3.1.</strong> Room Management</a></li><li class="chapter-item expanded "><a href="server/dependencies.html"><strong aria-hidden="true">3.2.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="server/states-sharing/states-sharing.html"><strong aria-hidden="true">3.3.</strong> States Sharing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="server/states-sharing/redis.html"><strong aria-hidden="true">3.3.1.</strong> Redis</a></li></ol></li><li class="chapter-item expanded "><a href="server/media-routing/media-routing.html"><strong aria-hidden="true">3.4.</strong> Media Routing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="server/media-routing/nats.html"><strong aria-hidden="true">3.4.1.</strong> NATS</a></li></ol></li><li class="chapter-item expanded "><a href="server/public-http-api.html"><strong aria-hidden="true">3.5.</strong> Public HTTP API</a></li><li class="chapter-item expanded "><a href="server/private-http-api.html"><strong aria-hidden="true">3.6.</strong> Private HTTP API</a></li><li class="chapter-item expanded "><a href="server/data-channel-api.html"><strong aria-hidden="true">3.7.</strong> Data Channel API</a></li><li class="chapter-item expanded "><a href="server/scaling.html"><strong aria-hidden="true">3.8.</strong> Scaling</a></li></ol></li><li class="chapter-item expanded "><a href="client/client.html"><strong aria-hidden="true">4.</strong> Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="client/join-as-publisher.html"><strong aria-hidden="true">4.1.</strong> Join as Publisher</a></li><li class="chapter-item expanded "><a href="client/join-as-subscriber.html"><strong aria-hidden="true">4.2.</strong> Join as Subscriber</a></li></ol></li><li class="chapter-item expanded "><a href="use-cases/use-cases.html"><strong aria-hidden="true">5.</strong> Use Cases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-cases/public-audio-chat.html"><strong aria-hidden="true">5.1.</strong> Public Audio Chat</a></li><li class="chapter-item expanded "><a href="use-cases/private-audio-chat.html"><strong aria-hidden="true">5.2.</strong> Private Audio Chat</a></li><li class="chapter-item expanded "><a href="use-cases/video-conferencing.html"><strong aria-hidden="true">5.3.</strong> Video Conferencing</a></li><li class="chapter-item expanded "><a href="use-cases/broadcasting.html"><strong aria-hidden="true">5.4.</strong> Broadcasting</a></li></ol></li><li class="chapter-item expanded "><a href="deployment/deployment.html"><strong aria-hidden="true">6.</strong> Deployment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="deployment/single-machine.html"><strong aria-hidden="true">6.1.</strong> Single Machine</a></li><li class="chapter-item expanded "><a href="deployment/docker-compose.html"><strong aria-hidden="true">6.2.</strong> Docker Compose</a></li><li class="chapter-item expanded "><a href="deployment/docker-swarm.html"><strong aria-hidden="true">6.3.</strong> Docker Swarm</a></li><li class="chapter-item expanded "><a href="deployment/kubernetes.html"><strong aria-hidden="true">6.4.</strong> Kubernetes</a></li></ol></li><li class="chapter-item expanded "><a href="metrics/metrics.html"><strong aria-hidden="true">7.</strong> Metrics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="metrics/prometheus.html"><strong aria-hidden="true">7.1.</strong> Prometheus</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Weever Streaming</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In this section, we will have a quick view about Weever Streaming.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Weever Streaming is a Open Source <a href="getting-started/../concepts/webrtc-sfu.html">WebRTC SFU</a>.</p>
<p>It serves for broadcasting, video conferencing, or regular video/audio/data streaming.</p>
<p>It's easy to deploy and scale.</p>
<p>You can come up with your own streaming products/platforms easily with it,
as long as you are familiar with HTML/CSS/JavaScript, and web service hosting.</p>
<p>You can also come up with non-web products/platforms,
as long as you can run HTTP client with WebRTC capability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>We will explain some WebRTC related concepts and Weever Streaming only concepts in this sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webrtc-sfu-selective-forwarding-unit"><a class="header" href="#webrtc-sfu-selective-forwarding-unit">WebRTC SFU (Selective Forwarding Unit)</a></h1>
<p>SFU is a server to help forwarding media.
It can communicate with clients to decide which media need forwarding.</p>
<p>For more details information please checkout <a href="https://bloggeek.me/webrtcglossary/sfu/">SFU (Selective Forwarding Unit) • BlogGeek.me</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdp-session-description-protocol"><a class="header" href="#sdp-session-description-protocol">SDP (Session Description Protocol)</a></h1>
<p>SDP is a widely adopted standard for describing the multimedia of the connection.</p>
<p>For more details information please checkout <a href="https://webrtchacks.com/sdp-anatomy/">Anatomy of a WebRTC SDP</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ice-interactive-connectivity-establishment-protocol"><a class="header" href="#ice-interactive-connectivity-establishment-protocol">ICE (Interactive Connectivity Establishment) Protocol</a></h1>
<p>ICE is a framework to allow peer to connect with another peer.
The ICE candidate will describe potential network path for connection.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stun-session-traversal-utilities-for-nat"><a class="header" href="#stun-session-traversal-utilities-for-nat">STUN (Session Traversal Utilities for NAT)</a></h1>
<p>STUN is a protocol to discover peer's public address and determine any restrictions in the router.</p>
<p>For more details information please checkout <a href="https://bloggeek.me/webrtcglossary/stun/">STUN • BlogGeek.me</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="turn--traversal-using-relays-around-nat"><a class="header" href="#turn--traversal-using-relays-around-nat">TURN  (Traversal Using Relays around NAT)</a></h1>
<p>TURN is a relay server to bypass the Symmetric NAT restriction.</p>
<p>For more details information please checkout <a href="https://bloggeek.me/webrtc-turn/">WebRTC TURN: Why you NEED it and when you DON’T need it</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publisher--subscriber"><a class="header" href="#publisher--subscriber">Publisher &amp; Subscriber</a></h1>
<p>Publisher and Subscriber are the only two roles in Weever Streaming.</p>
<p>Depends on use cases, the application can run both publisher and subscriber at the same time.</p>
<h2 id="publisher"><a class="header" href="#publisher">Publisher</a></h2>
<p>Publisher <strong>push</strong> media to Weever Streaming.
The media can be audio, video, or both.</p>
<h2 id="subscriber"><a class="header" href="#subscriber">Subscriber</a></h2>
<p>Subscriber <strong>pull</strong> media from Weever Streaming.
The media can be audio, video, or both.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="room"><a class="header" href="#room">Room</a></h1>
<p>A room in Weever Streaming maintains states of participating publishers/subscribers.</p>
<p>There is no different for hosting audio or video for a room.
A room can serve both audio and video.</p>
<p>There is no publishers or subscribers amount limitation for a room.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multistream"><a class="header" href="#multistream">Multistream</a></h1>
<p>Multistream means putting arbitrary amount of audio/video tracks in the same PeerConnection. <br />
(It's done via <a href="https://datatracker.ietf.org/doc/html/draft-roach-mmusic-unified-plan-00">Unified Plan</a> of SDP)</p>
<p>Combine with the widely adopted RTP BUNDLE and RTCP multiplexing.
This means we can serve both audio and video at the same time,
plus the control protocol,
for any amount of peers' media all in &quot;one single socket connection&quot;.</p>
<p>In Weever Streaming,
the <a href="concepts/./publisher-subscriber.html#subscriber">subscribers</a> will leverage multistream
for receiving all audio/video (from multiple <a href="concepts/./publisher-subscriber.html#publisher">publishers</a>) in single connection.</p>
<p>By Weever Streaming convention,
the stream id in SDP will be the publisher id.
So subscriber can identify each stream after parsing the SDP.
This also means subscribers can use info in SDP to know all the publishers.</p>
<p>To keep it simple,
publishers in Weever Streaming still use 1 connection for each outgoing streams.
Only subscribers fully leverage the multistream.</p>
<p>When a publisher join or leave,
server will trigger <a href="concepts/./webrtc-renegotiation.html">WebRTC Renegotiation</a> for subscribers.
New SDP will be sent via Data Channel.
Subscribers can use new SDP to get latest streams status in the room.</p>
<p>For more information about multistream, you can checkout Janus's article <a href="https://www.meetecho.com/blog/multistream/">Multistream is here!</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webrtc-renegotiation"><a class="header" href="#webrtc-renegotiation">WebRTC Renegotiation</a></h1>
<p>After WebRTC is connected,
you can still update the SDP for latest media status.</p>
<p>To achieve WebRTC Renegotiation,
you simply go through the WebRTC Negotiation flow one more time.
Send SDP Offer to the other peer. Receive and set SDP Answer.</p>
<p>The SDP Offer can be initiated by any peer,
not necessary the peer who sent SDP Offer in first setup.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whip--whep"><a class="header" href="#whip--whep">WHIP &amp; WHEP</a></h1>
<h2 id="whip-webrtc-http-ingestion-protocol"><a class="header" href="#whip-webrtc-http-ingestion-protocol">WHIP (WebRTC-HTTP Ingestion Protocol)</a></h2>
<p>The <a href="https://datatracker.ietf.org/doc/draft-ietf-wish-whip/">WHIP</a>
is a spec for pushing WebRTC-based media into services.
It provides a spec for WebRTC signaling with HTTP protocol and Bearer Token in pushing to services scenario.</p>
<p>Weever Streaming has WHIP-like media ingress.
It's WHIP-&quot;like&quot; because there is no guarantee about spec compliance at the moment.
But this project learned the idea from there.</p>
<p>And it's possible to use WHIP clients to publish audio/video to Weever Streaming.</p>
<p>WHIP Clients:</p>
<ul>
<li><a href="https://github.com/meetecho/simple-whip-client">simple-whip-client</a> (GStreamer based)
<ul>
<li><code>./whip-client -u https://localhost:8443/pub/testroom/user1 -t mytoken -V &quot;videotestsrc is-live=true pattern=smpte ! videoconvert ! video/x-raw,width=1280,height=720,framerate=60/1 ! queue ! vp8enc deadline=1 ! rtpvp8pay pt=96 ssrc=2 ! queue ! application/x-rtp,media=video,encoding-name=VP8,payload=96&quot;</code></li>
</ul>
</li>
</ul>
<h2 id="whep-webrtc-http-egress-protocol"><a class="header" href="#whep-webrtc-http-egress-protocol">WHEP (WebRTC-HTTP Egress Protocol)</a></h2>
<p>The <a href="https://datatracker.ietf.org/doc/draft-murillo-whep/">WHEP</a>
is a spec for pulling WebRTC-based media from services.
It provides a spec for WebRTC signaling with HTTP protocol and Bearer Token in pulling from services scenario.
(The pulling version of WHIP.)</p>
<p>Weever Streaming has WHEP-like media egress.
It's WHEP-&quot;like&quot; because there is no guarantee about spec compliance at the moment.
Weever Streaming implemented similar idea before there is WHEP spec release.</p>
<p>And it's possible to use WHEP clients to pull audio/video from Weever Streaming.
But WHEP doesn't include renegotiation, so WHEP clients can't update media on the fly.</p>
<p>WHEP Clients:</p>
<ul>
<li><a href="https://github.com/meetecho/simple-whep-client">simple-whep-client</a> (GStreamer based)
<ul>
<li><code>./whep-client -u https://localhost:8443/sub/testroom/user2 -t mytoken</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-as-sdp-offer-first"><a class="header" href="#client-as-sdp-offer-first">Client as SDP Offer first</a></h1>
<p>In Weever Streaming, the clients always will be the SDP Offer side for connection setup.
No matter the clients want to be publisher or subscriber.
This make clients WebRTC connection setup to be 1 HTTP POST and response.</p>
<p>After WebRTC is connected, Weever Streaming will use Data Channel for following WebRTC Renegotiation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication"><a class="header" href="#authentication">Authentication</a></h1>
<p>Weever Streaming's authentication is done via Bearer Token.</p>
<p>Server can set the token for each publisher/subscriber.</p>
<p>Client connect to Weever Streaming with <code>Authorization: Bearer &lt;token&gt;</code> in HTTP headers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server"><a class="header" href="#server">Server</a></h1>
<p>This section will introduce the Weever Streaming server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="room-management"><a class="header" href="#room-management">Room Management</a></h1>
<p>In Weever Streaming there is &quot;<a href="server/../concepts/room.html">Room</a>&quot; concept.
A room can host audio and video streaming.</p>
<p>Server can set <a href="server/../concepts/authentication.html">Authentication</a> to control who can join room.
(via <a href="server/./private-http-api.html">Private HTTP API</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<p>Weever Streaming has 2 dependencies at the moment.</p>
<p>One is for states sharing, Weever Streaming use Redis at the moment.</p>
<p>Another is for media routing, Weever Streaming use NATS at the moment..</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="states-sharing"><a class="header" href="#states-sharing">States Sharing</a></h1>
<p>Weever Streaming use external service for states sharing.</p>
<p>States sharing will handle information like:</p>
<ul>
<li>media count in a room</li>
<li>publishers list in a room</li>
<li>subscribers list in a room</li>
</ul>
<p>It possible to have a internal states sharing implementation in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis"><a class="header" href="#redis">Redis</a></h1>
<p>When launching Weever Streaming, you can use CLI argument <code>--redis</code> or environment variable <code>REDIS</code> to assign <a href="https://redis.io">Redis</a> URL.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="media-routing"><a class="header" href="#media-routing">Media Routing</a></h1>
<p>Weever Streaming use external service for media routing.</p>
<p>Media routing will handle audio/video streams routing.
Pass the streams across Weever Streaming instances.
Forward streams to the Weever Streaming instances that need them.</p>
<p>It possible to have a internal media routing implementation in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nats"><a class="header" href="#nats">NATS</a></h1>
<p>When launching Weever Streaming, you can use CLI argument <code>--nats</code> or environment variable <code>NATS</code> to assign <a href="https://nats.io">NATS</a> URL.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public-http-api"><a class="header" href="#public-http-api">Public HTTP API</a></h1>
<p>Public HTTP APIs in Weever Streaming for publisher/subscriber connection.</p>
<div class="table-wrapper"><table><thead><tr><th>HTTP</th><th>Endpoint</th><th>Usage</th></tr></thead><tbody>
<tr><td>POST</td><td><code>/pub/&lt;room&gt;/&lt;id&gt;</code></td><td>Connect WebRTC as Publisher for <code>&lt;room&gt;</code> as <code>&lt;id&gt;</code></td></tr>
<tr><td>POST</td><td><code>/sub/&lt;room&gt;/&lt;id&gt;</code></td><td>Connect WebRTC as Subscriber for <code>&lt;room&gt;</code> as <code>&lt;id&gt;</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="private-http-api"><a class="header" href="#private-http-api">Private HTTP API</a></h1>
<p>There is one <strong>private</strong> HTTP server in Weever Streaming.
It servers for management. You can use these API to manage the room from other services.</p>
<div class="table-wrapper"><table><thead><tr><th>HTTP</th><th>Endpoint</th><th>Usage</th></tr></thead><tbody>
<tr><td>POST</td><td><code>/create/pub</code></td><td>Set authentication token<br />for Publisher for <code>&lt;room&gt;</code> for <code>&lt;id&gt;</code></td></tr>
<tr><td>POST</td><td><code>/create/sub</code></td><td>Set authentication token<br /> for Subscriber for <code>&lt;room&gt;</code> for <code>&lt;id&gt;</code></td></tr>
<tr><td>GET</td><td><code>/list/pub/&lt;room&gt;</code></td><td>Show publisher list of <code>&lt;room&gt;</code></td></tr>
<tr><td>GET</td><td><code>/list/sub/&lt;room&gt;</code></td><td>Show subscriber list of <code>&lt;room&gt;</code></td></tr>
<tr><td>GET</td><td><code>/metrics</code></td><td>Prometheus metrics</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="data-channel-api"><a class="header" href="#data-channel-api">Data Channel API</a></h1>
<p>A data channel labeled as &quot;<strong>control</strong>&quot; will be setup from server.
This data channel will be used for WebRTC Renegotiation or other connection actions.</p>
<h2 id="publisher-1"><a class="header" href="#publisher-1">Publisher</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Server/Client Send</th><th>Usage</th></tr></thead><tbody>
<tr><td>SDP_OFFER</td><td>Client Send</td><td>WebRTC Renegotiation</td></tr>
<tr><td>SDP_ANSWER</td><td>Server Send</td><td>WebRTC Renegotiation</td></tr>
<tr><td>STOP</td><td>Client Send</td><td>Actively close peer connection. (There is connection timeout for leaving peers even without this command.)</td></tr>
<tr><td>OK</td><td>Server Send</td><td>Let client know server received the message but there is no special actions.</td></tr>
</tbody></table>
</div>
<h2 id="subscriber-1"><a class="header" href="#subscriber-1">Subscriber</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Server/Client Send</th><th>Usage</th></tr></thead><tbody>
<tr><td>SDP_OFFER</td><td>Server Send</td><td>WebRTC Renegotiation</td></tr>
<tr><td>SDP_ANSWER</td><td>Client Send</td><td>WebRTC Renegotiation</td></tr>
<tr><td>PUB_JOIN</td><td>Server Send</td><td>A publisher joined the room</td></tr>
<tr><td>PUB_LEFT</td><td>Server Send</td><td>A publisher left the room</td></tr>
<tr><td>STOP</td><td>Client Send</td><td>Actively close peer connection. (There is connection timeout for leaving peers even without this command.)</td></tr>
<tr><td>OK</td><td>Server Send</td><td>Let client know server received the message but there is no special actions.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="scaling"><a class="header" href="#scaling">Scaling</a></h1>
<p>Weever Streaming scaling can be done by adding more instances.</p>
<p>Possible setup:</p>
<ul>
<li>All Weever Streaming shared the same external NATS service. In this style, Weever Streaming scaling doesn't bind with NATS scaling.</li>
<li>Each Weever Streaming has its own NATS sidecar. And NATS sidecars form a cluster by themselves. In this style, Weever Streaming scaling bind with NATS scaling.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client"><a class="header" href="#client">Client</a></h1>
<p>Weever Streaming client can be any programming language that supports HTTP and WebRTC.</p>
<p>Weever Streaming also shares many aspect with <a href="client/../concepts/whip-whep.html">WHIP &amp; WHEP</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="join-as-publisher"><a class="header" href="#join-as-publisher">Join as Publisher</a></h1>
<p>JavaScript example (based on browser API):</p>
<pre><code class="language-javascript">// create WebRTC peer connection
let pc = new RTCPeerConnection();
// create a data channel labeled as &quot;control&quot;
let dc = pc.createDataChannel(&quot;control&quot;);

// setup callback
pc.onicecandidate = function(event) {
    if (event.candidate) {
        // ...
    } else {
        let offer = pc.localDescription;

        let type = &quot;pub&quot;;
        let room = &quot;testroom&quot;;  // modify this
        let id = &quot;testuser&quot;;    // modify this
        let token = &quot;mysecret&quot;; // modify this
        let url = `/${type}/${room}/${id}`;   // modify this

        // send to Weever Streaming
        fetch(url, {
            method: &quot;POST&quot;,
            headers: {
                &quot;Content-Type&quot;: &quot;application/sdp&quot;,
                &quot;Authorization&quot;: `Bearer ${token}`,
            },
            body: offer.sdp,
        }).then(res =&gt; {
            res.text().then(function(answer) {
                pc.setRemoteDescription(new RTCSessionDescription({&quot;type&quot;: &quot;answer&quot;, &quot;sdp&quot;: answer}));
            })
        });
    }
}

// grab media (audio/video)
navigator.mediaDevices.getUserMedia({ audio: true, video: true })
    .then(stream =&gt; {
        stream.getTracks().forEach(track =&gt; pc.addTrack(track, stream));
        pc.createOffer()
            .then(offer =&gt; {
                // set local SDP offer
                // this will trigger ICE gathering, and then onicecandidate callback
                pc.setLocalDescription(offer);
            });
    });
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="join-as-subscriber"><a class="header" href="#join-as-subscriber">Join as Subscriber</a></h1>
<p>JavaScript example (based on browser API):</p>
<pre><code class="language-javascript">// create WebRTC peer connection
let pc = new RTCPeerConnection();
// create a data channel labeled as &quot;control&quot;
let dc = pc.createDataChannel(&quot;control&quot;);

// setup callback
pc.onicecandidate = function(event) {
    if (event.candidate) {
        // ...
    } else {
        let offer = pc.localDescription;

        let type = &quot;sub&quot;;
        let room = &quot;testroom&quot;;  // modify this
        let id = &quot;testuser&quot;;    // modify this
        let token = &quot;mysecret&quot;; // modify this
        let url = `/${type}/${room}/${id}`;   // modify this

        // send to Weever Streaming
        fetch(url, {
            method: &quot;POST&quot;,
            headers: {
                &quot;Content-Type&quot;: &quot;application/sdp&quot;,
                &quot;Authorization&quot;: `Bearer ${token}`,
            },
            body: offer.sdp,
        }).then(res =&gt; {
            res.text().then(function(answer) {
                pc.setRemoteDescription(new RTCSessionDescription({&quot;type&quot;: &quot;answer&quot;, &quot;sdp&quot;: answer}));
            })
        });
    }
}

// data channel messages
dc.onmessage = e =&gt; {
    // WebRTC Renegotiation
    if (e.data.startsWith(&quot;SDP_OFFER &quot;) == true) {
        let offer = e.data.slice(10);
        pc.setRemoteDescription(new RTCSessionDescription({&quot;type&quot;: &quot;offer&quot;, &quot;sdp&quot;: offer}));
        pc.createAnswer()
            .then(answer =&gt; {
                pc.setLocalDescription(answer);
                dc.send(&quot;SDP_ANSWER &quot; + answer.sdp);
            });
    }
}

pc.createOffer()
    .then(offer =&gt; {
        // set local SDP offer
        // this will trigger ICE gathering, and then onicecandidate callback
        pc.setLocalDescription(offer);
    });
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h1>
<p>This section will show some setup examples for different use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public-audio-chat"><a class="header" href="#public-audio-chat">Public Audio Chat</a></h1>
<h2 id="target"><a class="header" href="#target">Target</a></h2>
<p>An audio only chatting application.</p>
<p>Anyone can join the room and speak.<br />
Anyone can join the room and listen.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Application run both publisher and subscriber clients.</p>
<p>Publisher client only enable audio, grab audio from device's microphone.</p>
<p>Subscriber client play all the incoming audio via speaker.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="private-audio-chat"><a class="header" href="#private-audio-chat">Private Audio Chat</a></h1>
<h2 id="target-1"><a class="header" href="#target-1">Target</a></h2>
<p>An audio only chatting application.</p>
<p>Only people with invitation can join the room and speak.<br />
Only people with invitation can join the room and listen.<br />
One person might have permission to listen, but not necessary have permission to listen.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>Server set authentication for clients.</p>
<p>For person who has both speak and listen permission,
application run both publisher and subscriber clients.</p>
<p>For person who only has listen permission,
application only run subscriber client.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="video-conferencing"><a class="header" href="#video-conferencing">Video Conferencing</a></h1>
<h2 id="target-2"><a class="header" href="#target-2">Target</a></h2>
<p>An meeting application with both audio and video.</p>
<p>Only people with invitation can join the room and speak.<br />
Only people with invitation can join the room and listen.</p>
<h2 id="setup-2"><a class="header" href="#setup-2">Setup</a></h2>
<p>Server set authentication for clients.</p>
<p>Application run both publisher and subscriber clients.</p>
<p>Publishers enable both audio and video.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="broadcasting"><a class="header" href="#broadcasting">Broadcasting</a></h1>
<h2 id="target-3"><a class="header" href="#target-3">Target</a></h2>
<p>Only a few people have permission to speak and show video.<br />
Most of the people are just watching and listening.</p>
<h2 id="setup-3"><a class="header" href="#setup-3">Setup</a></h2>
<p>Server set authentication for clients.</p>
<p>Application run both publisher and subscriber clients for broadcasting organizer.</p>
<p>Publishers enable both audio and video.</p>
<p>Application only run subscriber for all the viewers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment"><a class="header" href="#deployment">Deployment</a></h1>
<p>This section will show how to deploy Weever Streaming in different platforms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-machine"><a class="header" href="#single-machine">Single Machine</a></h1>
<p>To run Weever Streaming with single machine,
you can:</p>
<ol>
<li>run Redis</li>
<li>run NATS</li>
<li>grab Weever Streaming binary (a single file) (You can download from <a href="https://github.com/embracer-freemode/weever-streaming/actions?query=branch%3Adevelop">GitHub Actions' artifacts</a>)</li>
<li>execute Weever Streaming binary with CLI paramenters</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy-with-docker-compose"><a class="header" href="#deploy-with-docker-compose">Deploy with Docker Compose</a></h1>
<pre><code>this will launch: 1 Redis, 3 NATS, 3 WebRTC SFU (Weever Streaming)

  ┌──────┐    ┌──────┐    ┌──────┐
  │ SFU1 ├──┐ │ SFU2 ├──┐ │ SFU3 ├──┐
  └───┬──┘  │ └───┬──┘  │ └───┬──┘  │
      │     │     │     │     │     │
  ┌───▼───┐ │ ┌───▼───┐ │ ┌───▼───┐ │
  │ NATS1 ◄─┼─► NATS2 ◄─┼─► NATS3 │ │
  └───────┘ │ └───────┘ │ └───────┘ │
            │           │           │
  ┌─────────▼───────────▼───────────▼──┐
  │               Redis                │
  └────────────────────────────────────┘
</code></pre>
<h2 id="start-your-docker-daemon"><a class="header" href="#start-your-docker-daemon">Start your docker daemon</a></h2>
<pre><code class="language-bash"># start your docker daemon
sudo systemctl start docker
</code></pre>
<h2 id="bring-up-weever-streaming"><a class="header" href="#bring-up-weever-streaming">Bring up Weever Streaming</a></h2>
<pre><code class="language-bash"># run in the root folder of the project, the one with &quot;docker-compose.yml&quot; in it
docker-compose up
# check status
docker-compose ls
docker-compose ps
docker-compose logs -f sfu1
</code></pre>
<h2 id="remove-weever-streaming"><a class="header" href="#remove-weever-streaming">Remove Weever Streaming</a></h2>
<pre><code class="language-bash">docker-compose down
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy-with-docker-swarm"><a class="header" href="#deploy-with-docker-swarm">Deploy with Docker Swarm</a></h1>
<h2 id="start-up-docker-swarm-mode"><a class="header" href="#start-up-docker-swarm-mode">Start up docker swarm mode</a></h2>
<pre><code class="language-bash"># start your docker daemon
sudo systemctl start docker
# run docker swarm node
docker swarm init
</code></pre>
<h2 id="have-all-the-nodes-you-want-join-the-swarm"><a class="header" href="#have-all-the-nodes-you-want-join-the-swarm">Have all the nodes you want join the swarm</a></h2>
<pre><code class="language-bash"># (optional) join the cluster in another machine
docker swarm join --token &lt;token&gt; &lt;ip:port&gt;
</code></pre>
<h2 id="deploy-weever-streaming-up"><a class="header" href="#deploy-weever-streaming-up">Deploy Weever Streaming up</a></h2>
<pre><code class="language-bash"># run in the root folder of the project, the one with &quot;docker-compose.yml&quot; in it
docker stack deploy --compose-file docker-compose.yml weever-streaming

# check status
docker stack ls
docker stack services weever-streaming
docker stack ps weever-streaming
docker service logs -f weever-streaming_sfu1
</code></pre>
<h2 id="remove-weever-streaming-from-the-swarm"><a class="header" href="#remove-weever-streaming-from-the-swarm">Remove Weever Streaming from the swarm</a></h2>
<pre><code class="language-bash">docker stack rm weever-streaming
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<p>(TODO: add helm chart in)</p>
<ul>
<li>SFU can be deployed with StatefulSet.</li>
<li>Override the SSL certs in Pod.</li>
<li>A LoadBalancer in front of public web server.</li>
<li>Setup liveness/readiness probe, point to SFU private web server.</li>
<li>Setup preStop hook, point to SFU private web server.</li>
<li>NATS instance can be another service or SFU Pod sidecar.</li>
<li>Redis instance can be another service.</li>
<li>HPA based on CPU usage, dynamically grows the Pod count.</li>
<li>Can use other complex mechanism to control minimum Pod count if you need to schedule big events. For example, a cronjob to read business data and calculate a desired minimum Pod count.</li>
<li>Use/Setup TURN server if needed.</li>
<li>Authentication can be enabled via <code>--auth</code>. It's using Bearer Token mechanism. Token can be set via private web server. Data will be saved in Redis (1 day TTL).</li>
<li>Management can be done via another service that talks to SFU via private web server.</li>
<li>CORS can be set via <code>--cors-domain &lt;DOMAIN&gt;</code></li>
<li>Most of configs can be set via both CLI arguments and environment variables.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics"><a class="header" href="#metrics">Metrics</a></h1>
<p>This section will show some way to monitor Weever Streaming status.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prometheus"><a class="header" href="#prometheus">Prometheus</a></h1>
<p>In Weever Streaming <a href="metrics/../server/private-http-api.html">Private HTTP API</a>,
there is Prometheus metrics at <code>/metrics</code>.</p>
<p>There is only publishers/subscribers count at the moment.
The clients count is categorized based on room and role type.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
